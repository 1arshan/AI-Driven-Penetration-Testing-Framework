import asyncio
import json
from typing import Dict, List, Any
from src.agents.base_agent import BaseAgent
from src.knowledge_base.security_kb import SecurityKnowledgeBase


class VulnerabilityDiscoveryAgent(BaseAgent):
    """
    Agent specialized for vulnerability discovery tasks.

    This agent analyzes reconnaissance results to identify potential
    vulnerabilities in discovered services.
    """

    def __init__(self, agent_id=None):
        """
        Initialize a vulnerability discovery agent.

        Args:
            agent_id: Optional unique ID for the agent
        """
        super().__init__(agent_type="vulnerability_discovery", agent_id=agent_id)
        self.kb = SecurityKnowledgeBase()

    def get_capabilities(self) -> List[str]:
        """
        Get the capabilities of this vulnerability discovery agent.

        Returns: List of capability strings
        """
        return [
            "vulnerability_discovery",
            "service_analysis",
            "cve_mapping",
            "risk_assessment",
            "exploit_potential"
        ]

    async def process_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process a vulnerability discovery task.

        Args:
            task: Dictionary containing the task details

        Returns: Dictionary containing the vulnerability discovery results
        """
        task_id = task.get("id")
        parent_task_id = task.get("parent_task_id")
        target = task.get("target")

        # Log the start of processing
        print(f"Starting vulnerability discovery for target: {target}")
        await self.update_task_status(
            task_id=task_id,
            status="in_progress",
            progress=10.0,
            message=f"Starting vulnerability discovery for {target}"
        )

        # Get parent task result (reconnaissance data)
        recon_data = None
        if parent_task_id:
            recon_result = await self.redis.get(f"result:{parent_task_id}")
            if recon_result:
                recon_data = json.loads(recon_result).get("result", {})

        # If no parent data, check if task has service data directly
        if not recon_data and "services" in task:
            recon_data = {"services": task.get("services"), "target": target}

        # If still no data, return an error
        if not recon_data or "services" not in recon_data:
            await self.update_task_status(
                task_id=task_id,
                status="failed",
                progress=0.0,
                message="No reconnaissance data available"
            )
            return {
                "status": "failed",
                "error": "No reconnaissance data available",
                "target": target
            }

        # Update status
        await self.update_task_status(
            task_id=task_id,
            status="in_progress",
            progress=20.0,
            message=f"Analyzing {len(recon_data.get('services', []))} services"
        )

        # Process each service for vulnerabilities
        vulnerability_findings = []

        for i, service in enumerate(recon_data.get("services", [])):
            service_name = service.get("service")
            version = service.get("version")
            port = service.get("port")

            # Update status
            progress = 20.0 + (i + 1) * 60.0 / len(recon_data.get("services", []))
            await self.update_task_status(
                task_id=task_id,
                status="in_progress",
                progress=progress,
                message=f"Analyzing {service_name} {version} on port {port}"
            )

            # Query knowledge base for vulnerabilities
            vuln_results = self.kb.query_vulnerabilities(
                query_text=f"{service_name} {version} vulnerability",
                n_results=5,
                affected_service=service_name
            )

            # Process vulnerability results
            service_vulns = []
            if vuln_results and vuln_results.get("documents") and len(vuln_results["documents"][0]) > 0:
                for j, doc in enumerate(vuln_results["documents"][0]):
                    if j < len(vuln_results["metadatas"][0]):
                        metadata = vuln_results["metadatas"][0][j]

                        # Calculate risk score (simplified)
                        risk_score = metadata.get("cvss_score", 0.0)
                        risk_level = "Critical" if risk_score >= 9.0 else "High" if risk_score >= 7.0 else "Medium" if risk_score >= 4.0 else "Low"

                        service_vulns.append({
                            "name": metadata.get("name", "Unknown vulnerability"),
                            "cve_id": metadata.get("cve_id", "No CVE"),
                            "cvss_score": risk_score,
                            "risk_level": risk_level,
                            "description": doc[:500] + "..." if len(doc) > 500 else doc,
                            "affected_service": service_name,
                            "affected_version": version,
                            "port": port
                        })

            # Add service findings
            if service_vulns:
                vulnerability_findings.append({
                    "service": service_name,
                    "version": version,
                    "port": port,
                    "vulnerabilities": service_vulns,
                    "total_vulnerabilities": len(service_vulns),
                    "highest_risk": max([v.get("cvss_score", 0.0) for v in service_vulns]) if service_vulns else 0.0
                })

        # Generate summary using Claude
        total_vulns = sum([f.get("total_vulnerabilities", 0) for f in vulnerability_findings])
        critical_vulns = sum(
            [len([v for v in f.get("vulnerabilities", []) if v.get("risk_level") == "Critical"]) for f in
             vulnerability_findings])
        high_vulns = sum([len([v for v in f.get("vulnerabilities", []) if v.get("risk_level") == "High"]) for f in
                          vulnerability_findings])

        summary_prompt = f"""
        Create a concise summary of vulnerability findings:

        Target: {target}
        Total vulnerabilities discovered: {total_vulns}
        Critical vulnerabilities: {critical_vulns}
        High-risk vulnerabilities: {high_vulns}

        Service breakdown:
        {json.dumps([{
            "service": f.get("service"),
            "version": f.get("version"),
            "total_vulnerabilities": f.get("total_vulnerabilities"),
            "highest_risk": f.get("highest_risk")
        } for f in vulnerability_findings], indent=2)}

        Please provide a brief, professional summary of these findings, highlighting the most critical security issues.
        """

        summary = await self.claude.generate_response(
            system_prompt="You are a security professional summarizing vulnerability findings.",
            user_message=summary_prompt
        )

        # Compile results
        result = {
            "target": target,
            "services_analyzed": len(recon_data.get("services", [])),
            "vulnerability_findings": vulnerability_findings,
            "total_vulnerabilities": total_vulns,
            "critical_vulnerabilities": critical_vulns,
            "high_risk_vulnerabilities": high_vulns,
            "summary": summary
        }

        return result

    async def analyze_service_vulnerabilities(self, service_name: str, version: str, port: int) -> List[Dict[str, Any]]:
        """
        Analyze vulnerabilities for a specific service.

        Args:
            service_name: Name of the service
            version: Version string
            port: Port number

        Returns: List of vulnerability dictionaries
        """
        # Query knowledge base for vulnerabilities
        vuln_results = self.kb.query_vulnerabilities(
            query_text=f"{service_name} {version} vulnerability",
            n_results=5,
            affected_service=service_name
        )

        # Process vulnerability results
        vulnerabilities = []
        if vuln_results and vuln_results.get("documents") and len(vuln_results["documents"][0]) > 0:
            for i, doc in enumerate(vuln_results["documents"][0]):
                if i < len(vuln_results["metadatas"][0]):
                    metadata = vuln_results["metadatas"][0][i]

                    # Calculate risk score (simplified)
                    risk_score = metadata.get("cvss_score", 0.0)
                    risk_level = "Critical" if risk_score >= 9.0 else "High" if risk_score >= 7.0 else "Medium" if risk_score >= 4.0 else "Low"

                    vulnerabilities.append({
                        "name": metadata.get("name", "Unknown vulnerability"),
                        "cve_id": metadata.get("cve_id", "No CVE"),
                        "cvss_score": risk_score,
                        "risk_level": risk_level,
                        "description": doc[:500] + "..." if len(doc) > 500 else doc,
                        "affected_service": service_name,
                        "affected_version": version,
                        "port": port
                    })

        return vulnerabilities